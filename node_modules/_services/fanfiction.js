var Promise = require('bluebird');
var request = Promise.promisifyAll(require(''+'request'));
var url = require('url');
var t = require('_i18n').t;
var React = require('react');
var StoryComponent = require('_components/Story.jsx');
var config = require('_config');
var path = require('path');
var fs = Promise.promisifyAll(require('fs'));
var converterService = require('./converter');

//load adapters ...
var adapters = {
    'www.fanfiction.net': require('./adapters/www.fanfiction.net.adapter')
};

module.exports = {
    //check the story
    check: function(_url) {
        return new Promise(function(resolve, reject) {
            var domain = url.parse(_url).host;
            if (!adapters[domain]) throw new Error(t.gettext('Unsupported domain'));
            request.getAsync(_url)
            //share data for the end stuff
            .spread(adapters[domain].process)
            .catch(function(e) {
                reject(new Error(t.gettext('Failed checking the story')));
            })
            .then(resolve);
        });
    },
    //download & transform a story
    download: function(_infos) {
        //concurrently fetch all chapters, because I said so
        return Promise.all(_infos.chapterLinks.map(function(link) {
            return request.getAsync(link);
        })).bind(this).reduce(function(total, current, index, arrayLength) {
            //Reduce everything with the story intro/summary as initial data
            //chapterName
            total += '<h1> Chapter ' + (index + 1) + ': ' + _infos.chapterNames[index] + '</h1>';
            //story
            total += adapters[_infos.websiteName].getFictionFromSource(current[1]);
            //break page
            total += '<br>';
            return total;
        }, React.renderComponentToString(StoryComponent({story: _infos})))
        .then(function(htmlStory) {
            this.tempFileName = _infos.storyName + ' - ' + _infos.authorName + '.html';
            this.tempFilePath = path.join(config.tempDirectory, this.tempFileName);

            function writeTemp() {
                return fs.writeFileAsync(this.tempFilePath, htmlStory)
                .disposer(function() {
                    return fs.unlinkAsync(this.tempFilePath);
                }.bind(this));
            }

            return Promise.using(writeTemp.call(this), function() {
                return converterService.convert(this.tempFilePath);
            }.bind(this));
        });
    }
}
